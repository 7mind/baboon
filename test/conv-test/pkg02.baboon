model convtest.testpkg

version "2.0.0"

root adt Adt0 {
   data B1 {
       f: str
   }

  data B2 {
      f: i32
  }
}

root data TransferOpt {
  u: uid
  ol: opt[lst[Adt0]]
  ml: map[str, lst[Adt0]]
}

root data AllBasicTypes: derived[json], derived[ueba] {
  vi8: i08
  vi16: i16
  vi32: i32
  vi64: i64

  vu8: u08
  vu16: u16
  vu32: u32
  vu64: u64

  vf32: f32
  vf64: f64
  vf128: f128

  vstr: str
  vbstr: bytes
  vuid: uid

  vbit: bit

  vtsu: tsu
  vtso: tso

  voptStr: opt[str]
  vlstI32: lst[i32]
  vsetStr: set[str]
  vmapStrI32: map[str, i32]

  voptLst: opt[lst[str]]
  vlstOpt: lst[opt[i32]]
  vmapLst: map[str, lst[i64]]
}

// Renamed types from v1.0.0
root data NewTypeName : was[OldTypeName] {
  value: str
}

enum NewEnumName : was[OldEnumName] {
  A
  B
}

root data NewEnumHolder {
  e: NewEnumName
}

root adt NewAdtName : was[OldAdtName] {
  data Branch1 {
    f: str
  }
}

ns newns {
  root data NewNamespacedType : was[oldns.OldNamespacedType] {
    x: i32
  }
}

root data FieldRenameTest {
  newFieldName: str was oldFieldName
  keepField: i32
}

// Enum with renamed members from v1.0.0
enum EnumMemberRenameTest {
  NewMemberA was OldMemberA
  NewMemberB was OldMemberB
  KeepMember
}

root data EnumMemberRenameHolder {
  e: EnumMemberRenameTest
}

// ADT with renamed branches from v1.0.0
root adt AdtBranchRenameTest {
  data NewBranchA: was[OldBranchA] {
    x: i32
  }
  data NewBranchB: was[OldBranchB] {
    y: str
  }
  data KeepBranch {
    z: bit
  }
}

// Same-namespace type rename test (should resolve OldInSameNs in the same ns)
ns samens {
  root data NewInSameNs : was[OldInSameNs] {
    value: i32
  }
}