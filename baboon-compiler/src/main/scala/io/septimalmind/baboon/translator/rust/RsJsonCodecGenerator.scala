package io.septimalmind.baboon.translator.rust

import io.septimalmind.baboon.CompilerTarget.RsTarget
import io.septimalmind.baboon.parser.model.RawMemberMeta
import io.septimalmind.baboon.translator.rust.RsDefnTranslator.toSnakeCase
import io.septimalmind.baboon.typer.model.*
import izumi.fundamentals.platform.strings.TextTree
import izumi.fundamentals.platform.strings.TextTree.*

class RsJsonCodecGenerator(
  trans: RsTypeTranslator,
  target: RsTarget,
  domain: Domain,
  evo: BaboonEvolution,
) extends RsCodecTranslator {

  override def translate(defn: DomainMember.User, rsRef: RsValue.RsType, srcRef: RsValue.RsType): Option[TextTree[RsValue]] = {
    if (isActive(defn.id)) {
      // For Rust, JSON codecs are handled via serde derive macros on the struct/enum definitions.
      // We don't need separate codec objects like in Scala/C#.
      // The actual serde attributes are generated by RsDefnTranslator.
      // Here we only generate helper methods for programmatic encode/decode.
      defn.defn match {
        case _: Typedef.Dto      => Some(genJsonHelpers(rsRef))
        case _: Typedef.Enum     => Some(genJsonHelpers(rsRef))
        case _: Typedef.Adt      => Some(genJsonHelpers(rsRef))
        case _: Typedef.Foreign  => None
        case _: Typedef.Contract => None
        case _: Typedef.Service  => None
      }
    } else None
  }

  private def genJsonHelpers(name: RsValue.RsType): TextTree[RsValue] = {
    q"""impl ${name.asName} {
       |    pub fn to_json(&self) -> Result<String, serde_json::Error> {
       |        serde_json::to_string(self)
       |    }
       |
       |    pub fn to_json_pretty(&self) -> Result<String, serde_json::Error> {
       |        serde_json::to_string_pretty(self)
       |    }
       |
       |    pub fn from_json(s: &str) -> Result<Self, serde_json::Error> {
       |        serde_json::from_str(s)
       |    }
       |
       |    pub fn to_json_value(&self) -> Result<serde_json::Value, serde_json::Error> {
       |        serde_json::to_value(self)
       |    }
       |
       |    pub fn from_json_value(v: serde_json::Value) -> Result<Self, serde_json::Error> {
       |        serde_json::from_value(v)
       |    }
       |}""".stripMargin
  }

  def codecName(name: RsValue.RsType): RsValue.RsType = {
    RsValue.RsType(name.crate, s"${name.name}_JsonCodec", name.fq)
  }

  override def isActive(id: TypeId): Boolean = {
    target.language.generateJsonCodecs && (target.language.generateJsonCodecsByDefault || domain.derivationRequests
      .getOrElse(RawMemberMeta.Derived("json"), Set.empty[TypeId]).contains(id))
  }

  override def id: String = "Json"
}
